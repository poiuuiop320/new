Destination Folder: C:\oraclexe\
Oracle Home: C:\oraclexe\app\oracle\product\11.2.0\server\
Oracle Base:C:\oraclexe\

Port for 'Oracle Database Listener': 1521
자바연동포트

Port for 'Oracle Services for Microsoft Transaction Server': 2030



Port for 'Oracle HTTP Listener': 8080
관리페이지 포트 

포트충돌이 있을 수 있을 경우 바꿔야 한다.

sqlplus

서비스 시작
 
system

Exec DBMS_XDB.SETHTTPPORT(7070);
포트변경


hr/hr

scott/tiger

@C:\oraclexe\app\oracle\product\11.2.0\server\rdbms\admin\scott.sql


system->alter user scott identified by tiger;


alter user hr account unlock identified by hr;

show user

conn hr/hr

conn scott/tiger
conn은 sql 연결후 안에서 커넥
sqlplus hr/hr

sqlplus scott/tiger
외부에서 접근할 경우 sqlplus를 사용

sqlplus scott/tiger@192.168.0.42:1521/orcl
원격접근


select * from tab;

 set line 200
 set pagesize 40
 select * from tab;

desc emp;

con tname format a40

SQL> con tname format a40
SP2-0734: unknown command beginning "con tname ..." - rest of line ignored.
SQL> col tname format a40
SQL> select * from tab;

TNAME                                    TABTYPE         CLUSTERID
---------------------------------------- -------------- ----------
BONUS                                    TABLE
DEPT                                     TABLE
EMP                                      TABLE
SALGRADE                                 TABLE

SQL> col tname format a20
SQL> select * from tab;

TNAME                TABTYPE         CLUSTERID
-------------------- -------------- ----------
BONUS                TABLE
DEPT                 TABLE
EMP                  TABLE
SALGRADE             TABLE


col 컬럼 format a길이

EMP 정보 구조를 보고싶을 경우

desc emp;

select *
from emp
/

select ename, job from emp;

desc dept;

 select deptno,dname,loc from dept;

select empno,ename,job,hiredate,sal from emp;

select empno,ename from emp where empno=7369;

select empno,ename,job,hiredate
from emp
where ename='FORD';

select empno,ename,sal*12 from emp;

 select empno,ename,sal*12 as yearsal
 from emp
 /

 select empno,ename,sal*12 as 연봉 from emp;

col yearsal format 9,999,9999
select empno,ename,sal*12 as yearsal from emp;

distinct중복제거

select 컬럼
           컬럼 연산 nvl 
from 테이블 
where 조건


from dual;

hiredate='81/12/03';

hiredate='81-09-28';

 select empno,ename,job,deptno
 from emp
 where deptno=10 or deptno =20

select empno,ename,sal,hiredate,job
from emp
where job='MANAGER' OR job='CLERK'


 select empno,ename,sal,hiredate,job
 from emp
 where job in ('MANAGER','CLERK')

 select *
 from emp
 where comm in (300,500,1400);

select empno,sal
from emp
where sal=1250 or sal=1500;

EMPNO        SAL
----- ----------
 7521       1250
 7654       1250
 7844       1500

select empno,sal
from emp
where sal in(1250,1500);

EMPNO        SAL
----- ----------
 7521       1250
 7654       1250
 7844       1500

select ename
from emp
where comm not in (300,500,1400);


select *
from emp
where comm<>300 and comm<>500 and comm<>1400;



 select empno,ename,sal
 from emp
 where sal<=3000 and sal>=2000;


select empno,ename,sal
from emp
where sal between 2000 and 3000;

* 
?

a% a로 시작하는 경우 검색

%a a로 끝나는 경우를 검색

&a&

_a_

select *
from emp;
where ename like'f%';

select empno,ename,hiredate
from
emp
where ename like 'K%';

select ename,deptno
from emp
where ename list '%B%';


select ename,deptno,job ,hiredate
from emp
where hiredate like'81%';

select empno,ename from emp
where ename like'K%';

select empno,ename from emp
where ename like'%K';


select empno,ename from emp
where ename like'%K%';

select *
from emp
where ename like'_A%';

select empno,ename,job
from emp
where ename like'____';

select ename,sal,deptno
from emp
where ename like'%R_%;

SAL*12+NVL(COMM,0)

nvl 함수  커미션의 null값을 0으로 대체

 select empno,ename,comm
 from emp
 where comm is null;

select empno,ename,comm
from emp
where comm is not null;

select * from emp
where mgr is null;



 select * from t1
 where name like '%A!_A%' escape'!';

select * from t1
where name like '%A_A%'; 언더바가 들어간 이름이있다면 

문자라고 인식하고 싶을 때 escape' ' 를 사용한다.


 select * from t1
 where name like '%A#_A%' escape'#';


select
from
where
group by
having
order by


 create table t1
 (
 name varchar2(10)
 )
 ;

insert into t1 values('AAA');

 select empno,ename,hiredate
 from emp
 order by hiredate;

select empno,ename,hiredate
from emp
order by hiredate desc;

select empno,ename,hiredate,deptno
from emp
order by deptno ;

l      /          r

 ed test.sql

 host

dir/w/p

>exit

 @test

create table tt2
(
name varchar2(20)
,age number(3)
);

insert into tt2 values('hong',20);
insert into tt2 values('kim',10);

 save emp.sql

 host

dir/w/p

@emp

 ed emp.sql

ddl정의어  create alter drop
dcl제어어 grant revoke
dml조작어 insert update delete
dql질의어 select 
tcl트랜잭션 commit rollback


select	컬럼,컬럼2,컬럼3 as 별칭
from	테이블명
where	
컬럼 between a and b
in ('a','b','c')
'a' or 'b' or 'c'
like _ , % 

select
from
where
order by


  1  select ceil(10.2),ceil(10.9),ceil(-10.2),ceil(-10.9)
  2* from dual
SQL> /

CEIL(10.2) CEIL(10.9) CEIL(-10.2) CEIL(-10.9)
---------- ---------- ----------- -----------
        11         11         -10         -10


SQL> select floor(10.2),floor(10.9),floor(-10.0),floor(-10.2),floor(-10.9)
  2  from dual;

FLOOR(10.2) FLOOR(10.9) FLOOR(-10.0) FLOOR(-10.2) FLOOR(-10.9)
----------- ----------- ------------ ------------ ------------
         10          10          -10          -11          -11

conn hr/hr

select * from tab;

 desc employees;
 desc jobs;



select employee_id,salary*nvl(commission_pct,0)/100 as comm
from employees;


select employee_id,salary*nvl(commission_pct,0)/100 as comm1
,ceil(salary*nvl(commission_pct,0)/100) as comm2
from employees
/


MOD(n2, n1)

SQL> select mod(10,3),mod(2,2),mod(2,0),mod(-10,3)
  2  from dual;

 MOD(10,3)   MOD(2,2)   MOD(2,0) MOD(-10,3)
---------- ---------- ---------- ----------
         1          0          2         -1

ABS(n)

크기만 표현함 

FLOOR(n)
내림값 표현
MOD(n1,n2)
n1에 대한 나머지값


 select *
 from emp
 where mod(empno,2)=1

POWER(n2, n1)

select power(2,3),power(2,0),power(4,-1)
from dual

ROUND(n [, integer ])

SQL> select round(10.2),round(10.9)
  2  from dual;

ROUND(10.2) ROUND(10.9)
----------- -----------
         10          11


select round(10.2),round(10.9),round(-10.2),round(-10.9)
from dual

select round(10.2),round(10.9),round(-10.2),round(-10.9),round(10.0)
from dual

select round(10.2323,1),round(10.256,1),round(113,-1),round(117,-1)
from dual;

TRUNC(n1 [, n2 ])


select TRUNC(10.3245),TRUNC(10.5678) from dual;

select TRUNC(-10.3245),TRUNC(-10.5678) from dual;

select TRUNC(10.3245,1),TRUNC(10.5678,1),TRUNC(-10.3245,1),TRUNC(-10.5678,1) from dual;

select TRUNC(10.3245,1),TRUNC(10.5678,1),TRUNC(-10.3245,1),TRUNC(-10.5678,1) from dual;



select empno,ename
 from emp
 where trunc(sal/1000) in(2,3)

select empno,ename
 from emp
 where floor(sal/1000) in(2,3)

where trun(sal,-3)=2000 or trunc(sal,-3)=3000
where trunc(sal,-3) in (2000,3000)

select empno,ename
from emp
where trunc(empno/100)=75;
where trunc(empno,-2)=7500;


select chr(65),chr(97),chr(40) from dual;

CHR(n [ USING NCHAR_CS ])


CONCAT(char1, char2)

select empno||ename from emp;
select concat(empno,ename) from emp;

select concat(empno,'s name is'), ename from emp;


INITCAP(char)

select initcap('abc'),initcap('Abc'),initcap('aBCD'),initcap('ABCD') from dual
select initcap('hong gil dong') from dual;


LOWER(char)
UPPER(char)
select lower('abc'),upper('Abc'),lower('aBCD'),upper('ABCD') from dual

select empno,ename,job
from emp
where lower(job)='manager'


select ascii('a'),ascii('A')
from dual;

{ INSTR
| INSTRB
| INSTRC
| INSTR2
| INSTR4
}
(string , substring [, position [, occurrence ] ])

 select instr('abcdabcd','a')
 from dual
select instr('abcdabcd','c')
from dual



select instr('honggildong','gil') from dual;

문자의 위치 검색

 select instr('honggildonghonggildong','gil',6) from dual;
SQL> select instr('abcdabcdabcdabcd','a',1,5) from dual;


 1  select length('홍길동'),length('abc')
 2  ,lengthb('홍길동'),lengthb('abc')
 3  ,lengthc('홍길동'),lengthc('abc')
 4* from dual

select length('홍길동'),length('abc')
,lengthb('홍길동'),lengthb('abc')
,lengthc('홍길동'),lengthc('abc'),
length2('홍길동'),length2('abc'),
length4('홍길동'),length4('abc')
from dual


select length('       abcd       '), length( ltrim('       abcd       ')) from dual;
select length('       abc d       '), length( ltrim('       abc d       ')) from dual;

select ltrim('========abc d========','=') from dual
select rtrim(ltrim('========abc d========','='),'=') from dual


trim or 로 찾고 삭제됨 


select lpad('abcdabcd',20,'*') from dual;

select lpad('abcdabcd',10,'*') from dual;

select lpad('abcdeabcde',10,'*') from dual;

select lpad('abcdeabcde',11,'*') from dual;

select lpad('a',5,'*') from dual;


select *
from emp
where upper(ename) like '__R%'

TRIM([ { { LEADING | TRAILING | BOTH }
         [ trim_character ]
       | trim_character
       }
       FROM 
     ]
     trim_source
    )

select trim (both 'a' from 'abaaa') from dual;

select trim (leading 'a' from 'abaaa') from dual;

 select empno,ename,sal
 ,trunc(sal/1000)
 from emp
 /

select empno,ename,sal
,trunc(sal/1000)+1
from emp;


select empno,ename,sal
,lpad(' ',trunc(sal/1000),'*') as result from emp
/

 select empno,ename,sal
 ,nvl(trim(lpad(' ',trunc(sal/1000)+1,'*')),'no')
  as result
 from emp
 /

 select empno,ename,sal
 ,lpad(' ',trunc(sal/1000)+1,'*') as result from emp
 /
select replace('abcdabcd' ,'a','hello') from dual;
select replace( 'abcdefghigklmn','b','hi hello') from dual;



 select substr('hong gil dong' ,2) from dual;

select substr('hong gil dong' ,2,5) from dual;
                                 length

대상 위치 개수


sysdate

 select substr(sysdate,4,2) from dual;

select ename,job,hiredate
from emp

where substr(hiredate,1,2)=81
where hiredate>='81-01-01' and hiredate<='81-12-31'
where hiredate between '81-01-01' and '81-12-31'

select ename,job,hiredate
from emp
where upper(ename) like '%E'
where substr(upper(ename),-1,1)='E'
where upper(ename) like '%E_'
where substr(upper(ename),-2,1)='E'
where substr(upper(ename),-3,1)='N'

select length( to_char(sysdate)) from dual;

select to_char(sysdate,'yyyy-mm-dd hh24:mi:ss') from dual;
select to_char(sysdate,'yy-mm-dd hh24:mi:ss') from dual;

to_char(sysdate,'mm d dd ddd'),
                    day date day of year
to_char(sysdate,'hh'),
to_char(sysdate,'mon')

select to_char(sysdate,'yyyy-mm-dd hh24:mi:ss')
to_char(sysdate,'mm d dd ddd'),
to_char(sysdate,'hh'),
to_char(sysdate,'mon')
 from dual
/

sqlplus scott/tiger@192.168.0.50:1521/XE
sqlplus scott/tiger@192.168.0.29:1521/XE
sqlplus scott/tiger@192.168.0.27:1521/XE

arp -a

 192.168.0.1
 192.168.0.24
 192.168.0.25
 192.168.0.29
 192.168.0.32
 192.168.0.33
 192.168.0.36
 192.168.0.39
 192.168.0.42
 192.168.0.43
 192.168.0.44
 192.168.0.50
 192.168.0.60
select sysdate,sysdate+1,sysdate+2 from dual;
select sysdate,sysdate+1,sysdate+2,sysdate+30 from dual;
select sysdate,sysdate+1,sysdate+2,sysdate+30,sysdate-30 from dual;

select empno,ename,sysdate-hiredate as 근무일수
from emp
/

to_date to_char to_number

to_char n값과 타입을 넣음

TO_CHAR(n [, fmt [, 'nlsparam' ] ])

문자로 변경
숫자로 변경
select to_char(1942,'9,990') from dual;
문자화

select to_char(sysdate,'hh24:mi:ss') from dual;
select to_char(sysdate,'hh:mi:ss') from dual;
 select to_char(102456.23456,'$9,999,990.9')from dual;
select to_char(102456.28456,'$9,999,990.9')from dual;
문자는 왼쪽부터 채워짐 숫자는 오른쪽부터 채워짐

select to_char(102456.28456,'$9,999,990.9'),102456.28456 as count from dual;
select to_char(102456.28456,'l9,999,990.9'),102456.28456 as count from dual;
                             L : local

select to_char(sysdate,'am') from dual;
select to_char(sysdate,'ad') from dual;
select to_char(sysdate,'bc') from dual;
select to_char(sysdate,'d') from dual;
select to_char(sysdate,'dd') from dual;
select to_char(sysdate,'day d dd ddd') from dual;
       to_char(sysdate,'dy') day, dy ->수요일, 수
select to_char(sysdate,'j')from dual;
julian day
select to_char(sysdate,'q')from dual;
Quarter of year (1, 2, 3, 4)
 select to_char(sysdate,'iw')from dual;
week
 to_date('2017-02-01','yyyy-mm-dd')
                       형식을 맞춤

'17-02-01','yy-mm-dd'


  to_char   to_char

숫자    문자    날짜

 to_number to_date
select to_number('1,200','9,999')-1000 from dual;
' '안에 문자형식을 to_number로 변환
select empno,ename,nvl(to_char(comm),'no data') as R
 from emp


nvl 널 값일 경우


select round(to_date('2017-02-01','yyyy-mm-dd'),'month') 16일기준
                                                 'year' 등등 타입으로 기준 7월기준
from dual
/
 select sysdate
 ,round(sysdate,'yyy')
 ,round(sysdate,'mm')
 ,round(sysdate,'dd')
 ,to_char(round(sysdate,'hh24'),'yyyy-mm-dd hh24:mi:ss')
 from dual

select trunc(to_date('2017-02-01'),'yyyy') from dual;


select sysdate+1,add_months(sysdate,1)from dual;


select current_date from dual;
select to_char(current_date,'dd-mon-yyyy hh24:mi:ss') from dual;


select last_day(sysdate) from dual;
select last_day(sysdate),last_day(to_date('2017-08-03')) from dual;

between a and b
in (a,b)
like

숫자  abs ceil floor trunc round
문자  trim replace instr substr upper lower initcap 
날짜  sysdate add_months 

to_date
to_char
to_number

, 0 $ L 0 9 


select next_day('2017-02-02','화요일')from dual;
select to_date('2016-02-01')-1 from dual;
select last_day(to_date('2017-02-01')) from dual;
select next_day('2017-02-03','금요일')from dual;
select months_between(sysdate,to_date('2016-10-03')) as mon from dual;
select months_between(sysdate,to_date('2016-10-13')) as month from dual;
select to_char(round(sysdate,'dd'),'yyyy-mm-dd hh24:mi:ss') from dual;
select empno,ename,sysdate-hiredate as jobday
,months_between(sysdate,hiredate) jobmonth
from emp;

select empno,ename,(sysdate-hiredate)/365 as jobday
,months_between(sysdate,hiredate)/12 jobmonth
from emp;
select add_months(to_date('2017-02-02'),5) from dual;
select add_months(to_date('2017-03-31'),1) from dual;
select add_months(to_date('2017-04-30'),1) from dual;
select to_char(123000) from dual;
select 123000 from dual;
select to_char(1230000,'l999,999,999') from dual;
select to_number('10,230,000','999,999,999') from dual;
select to_number('2,222,220','999,999,999')-10000 from dual;


select empno,ename,nvl(to_char(mgr),'ceo') as mgr
from emp
where mgr is null
/



select empno,ename,
decode(deptno, 10,'인사',
                20,'기획',
                30,'홍보',
                '부서없음') as dname
from emp
/

select empno,ename,job,sal,
decode(job, 'ANALYST',sal+sal*0.05,
                'SALESMAN',sal*1.1,
                'MANAGER',sal*1.15,
                'CLERK',sal*1.2,
                  sal) as upsal
from emp

select empno,ename,job,sal,deptno,
case deptno when 10 then '인사'
             when 20 then'기획'
            when 30  then '홍보'
           else '부서없음'
  end 
as dname
from emp
/


 select empno,ename,job,sal,
 case deptno when 10 then '인사'
              when 20 then'기획'
             when 30  then '홍보'
            else '부서없음'
   end as 부서,
case
 when deptno=10 then'인사'
when deptno=20 then'기획'
when deptno=30 then'홍보'
else '부서없음'
end 
as 부서2
 from emp
/

 select empno,ename,job,sal,
 case deptno when 10 then '인사'
              when 20 then'기획'
             when 30  then '홍보'
            else '부서없음'
   end as 부서,
case
 when deptno=10 then'인사'
when deptno=20 then'기획'
when deptno=30 then'홍보'
else '부서없음'
end 
as 부서2
from emp/
/

select empno,ename,sal,
decode(trunc(sal/1000),0,'부족'
          ,1,'적당'
          ,2,'만족' ,3,'만족',4,'만족'
,5,'감동') as result
,case
     when sal<1000  then '부족'
     when sal>=1000 and sal<3000 then '적당'
     when sal>=3000 and sal<5000 then '만족'
     when sal>=5000 then '감동'
end as case1
from emp
/

Aggregate Functions
group function 

avg
count
collect
max
min
rank
sum
last
median
select sum(sal),count(sal),max(sal),min(sal),avg(sal)from emp;


create table sungjuck
(
hak number(6) constraint pk_hak primary key
,name varchar2(20) constraint nn_name not null
,jumsu number(3)
);
primary key
not null
unique 
foreign key
default

 insert into sungjuck values(1,'a',100);
insert into sungjuck values(2,'b',50);
insert into sungjuck(hak,name) values(3,'c');
insert into sungjuck values(4,'d',null);

select * from sungjuck where jumsu is null;
select * from sungjuck where jumsu is not null;
select sum(jumsu),count(jumsu),max(jumsu),min(jumsu) from sungjuck;
 select sum(jumsu),count(jumsu),max(jumsu),min(jumsu),count(*) from sungjuck;
count(*)

select 
avg(jumsu),
sum(jumsu)/count(jumsu) as av1,
sum(jumsu)/count(*) as av2 from sungjuck;

그룹과 칼럼선택은 같은선택을 할 수 없다

select max(hiredate),min(hiredate) from emp;
 select count(comm)from emp where deptno=10;
select count(comm) from emp where deptno=30;
 select count(job) 업무수 from emp;

select distinct deptno from emp;
select count(deptno)from emp;
select count(distinct deptno)from emp;
select count(distinct job)from emp;
select avg(sal),count(sal) from emp
select avg(sal),count(sal) from emp
group by deptno
/
select deptno,avg(sal),count(sal) from emp
group by deptno
/

select job,avg(sal) from emp
group by job
/

 select deptno,job,avg(sal),count(sal) from emp
 group by deptno,job
 /

select deptno,job,avg(sal),count(sal) from emp
group by deptno,job
order by deptno,job
/

select JOB_ID,DEPARTMENT_ID, avg(SALARY)
 from employees
group by JOB_ID ,DEPARTMENT_ID

/

select substr(HIRE_DATE,1,2), avg(SALARY),max(SALARY),min(SALARY)
 from employees
group by substr(HIRE_DATE,1,2)
/
select to_char(hire_date,'yyyy') ,avg(SALARY)
from employees
group by  to_char(hire_date,'yyyy')
/

select distinct to_char(hire_date,'yyyy') from employees;


SQL> select decode(to_char(hire_date,'yyyy'),'2001',1) from employees;

select sum(decode(to_char(hire_date,'yyyy'),'2001',1)) from employees
select sum(decode(to_char(hire_date,'yyyy'),'2001',1))
,sum(decode(to_char(hire_date,'yyyy'),'2002',1))
,sum(decode(to_char(hire_date,'yyyy'),'2003',1))
,sum(decode(to_char(hire_date,'yyyy'),'2004',1))
,sum(decode(to_char(hire_date,'yyyy'),'2005',1))
,sum(decode(to_char(hire_date,'yyyy'),'2006',1))
,sum(decode(to_char(hire_date,'yyyy'),'2007',1))
,sum(decode(to_char(hire_date,'yyyy'),'2008',1))
from employees
/


select avg(decode(to_char(hire_date,'yyyy'),'2001',salary)) as 1
,avg(decode(to_char(hire_date,'yyyy'),'2002',salary)) as 2
,avg(decode(to_char(hire_date,'yyyy'),'2003',salary)) as 3
,avg(decode(to_char(hire_date,'yyyy'),'2004',salary)) as 4
,avg(decode(to_char(hire_date,'yyyy'),'2005',salary)) as 5
,avg(decode(to_char(hire_date,'yyyy'),'2006',salary)) as 6
,avg(decode(to_char(hire_date,'yyyy'),'2007',salary)) as 7
,avg(decode(to_char(hire_date,'yyyy'),'2008',salary)) as 8 
from employees
/



select department_id
from employees
group by department_id
/

select to_char(hire_date,'yy')
from employees
group by to_char(hire_date,'yy');

select avg(decode(to_char(hire_date,'yyyy'),'2001',salary)) as a
,avg(decode(to_char(hire_date,'yyyy'),'2002',salary)) as b
,avg(decode(to_char(hire_date,'yyyy'),'2003',salary)) as c
,avg(decode(to_char(hire_date,'yyyy'),'2004',salary)) as d
,avg(decode(to_char(hire_date,'yyyy'),'2005',salary)) as e
,avg(decode(to_char(hire_date,'yyyy'),'2006',salary)) as f
,avg(decode(to_char(hire_date,'yyyy'),'2007',salary)) as g
,avg(decode(to_char(hire_date,'yyyy'),'2008',salary)) as h
from employees
/

select decode(to_char(hire_date,'yyyy'),'2001',salary) as a
,decode(to_char(hire_date,'yyyy'),'2002',salary) as b
,decode(to_char(hire_date,'yyyy'),'2003',salary) as c
,decode(to_char(hire_date,'yyyy'),'2004',salary) as d
,decode(to_char(hire_date,'yyyy'),'2005',salary) as e
,decode(to_char(hire_date,'yyyy'),'2006',salary) as f
,decode(to_char(hire_date,'yyyy'),'2007',salary) as g
,decode(to_char(hire_date,'yyyy'),'2008',salary) as h
from employees
/

select department_id, avg(salary) from employees group by department_id ;


select department_id, lpad(' ',avg(salary)/1000,'*') as A
from employees
group by department_id
/
select department_id,avg(salary), lpad(' ',avg(salary)/1000,'*') as A
from employees
group by department_id
/



select department_id,avg(salary)
,trunc(avg(salary)/1000)
from employees
group by department_id

/


select department_id, avg(salary), max(salary), min(salary)
from employees
group by department_id


 select
 decode(department_id,'10', avg(salary)) as a
 ,decode(department_id,'10', max(salary)) as b
 ,decode(department_id,'10', min(salary)) as c
 ,decode(department_id,'20', avg(salary)) as d
 ,decode(department_id,'20', max(salary)) as e
 ,decode(department_id,'20', min(salary)) as f
 from employees
 group by department_id
 /


select job_id,department_id,avg(salary)
from employees
group by job_id,department_id
/

select trunc(months_between(sysdate,hire_date)/12) as year
,sum(decode(department_id,'10',1))
from employees
group by trunc(months_between(sysdate,hire_date)/12)
/

select corr(sysdate-hire_date,salary)from employees;

select department_id,avg(salary)
from employees
where department_id=10
group by department_id

/

select department_id,avg(salary)
from employees
group by department_id
having department_id=10
/

select distinct department_id,avg(salary)
from employees
group by department_id


그룹에서 필터 
전체 필터에서 그룹

select department_id ,max(salary),min(salary)
from employees
group by department_id
having max(salary)<10000
/
select department_id,avg(salary),max(salary),min(salary)
from employees
where department_id in ( 20, 30)
group by department_id
/
select department_id , salary,rank() over( order by salary) as r from employees;

select department_id , salary,rank() over( order by salary desc) as r from employees;

select avg(nvl(jumsu,0)) from sungjuck;
select sum(jumsu)/count(*) from sungjuck;

select job_id,avg(salary) from employees group by job_id;
select job_id,avg(salary) from employees where department_id =50 group by job_id;
select job_id,department_id,avg(salary) from employees group by job_id,department_id having department_id=50 ;
select tname from tab;

 drop table T1 purge;
purge recyclebin;
show recyclebin;
flashback table p1 to before drop;

 select empno,ename,dname
 from emp,dept;
select count(deptno) from dept;
select count(empno) from emp;
cross join
equi join
select empno,ename,dname from emp,dept where dept.deptno=emp.deptno;
select * from emp,dept where dept.deptno=emp.deptno;
select * from emp,dept where dept.deptno=emp.deptno and DNAME='SALES';
desc employees
desc jobs
 select * 
from employees,jobs 
where employees.job_id=jobs.job_id;

select department_id,employee_id,first_name,last_name,job_title 
from employees,jobs 
where employees.job_id=jobs.job_id;

select department_id,employee_id,first_name||last_name as name,job_title 
from employees,jobs 
where employees.job_id=jobs.job_id;

select department_id,employee_id,first_name||last_name as name,job_title as jobs,min_salary,max_salary 
from employees,jobs 
where employees.job_id=jobs.job_id;

select department_id,employee_id,first_name||last_name as name,job_title as jobs,min_salary,max_salary 
from employees,jobs 
where employees.job_id=jobs.job_id and job_title='Marketing Manager';

4 select
1 from
2 where
3 group by
5 having
6 order by
우선순위 인식범위

select * from employees,jobs where employees.job_id=jobs.job_id;
select * from employees e,jobs j where e.job_id=j.job_id;

COUNTRIES
DEPARTMENTS
EMPLOYEES
EMP_DETAILS_VIEW
JOBS
JOB_HISTORY
LOCATIONS
REGIONS

select ename,sal from dept d,emp e where d.deptno=e.deptno;

 desc dept;
desc emp;
select ename,sal,d.loc from dept d,emp e where d.deptno=e.deptno and loc='NEW YORK';
 select * from emp e ,dept d, salgrade s where e.deptno=d.deptno and e.sal>=s.losal and e.sal <=hisal ;

 e.sal>=s.losal and e.sal <=hisal;

  select first_name,department_name 
from employees e, departments d,locations l 
where e.department_id=d.department_id 
and d.location_id=l.location_id 
and department_name ='Finance';

select first_name,department_name,city,country_name
from employees e, departments d,locations l ,countries c
where e.department_id=d.department_id
      and d.location_id=l.location_id
      and l.country_id=c.country_id
and department_name ='Finance'
/
select e1.ename,e1.deptno, e2.ename,e2.deptno
from emp e1,emp e2
where e1.mgr=e2.empno
/
select e1.ename,e1.deptno,e1.sal,e1.hiredate
from emp e1,emp e2
where e1.mgr=e2.empno
and e2.ename='KING'
/

select e2.ename,e2.sal,e2.hiredate
from emp e1,emp e2
where e1.mgr=e2.empno
and e1.ename='SMITH'
/


select * from emp,dept where dept.deptno=emp.deptno and dept.dname='RESEARCH';
select * from emp,dept where dept.deptno=emp.deptno and dept.loc='DALLAS';

select e2.ename
from emp e1,emp e2
where e1.deptno=e2.deptno
and e1.ename='SMITH'

select e2.ename, e1.deptno,e2.deptno
from emp e1,emp e2
where e1.deptno=e2.deptno
and e1.ename='FORD'

select employee_id , salary
from employees
where salary >=3000 and salary<=10000
or salary between   3000 and 10000
order by salary desc

select employee_id , job_id,COMMISSION_PCT
from employees
where COMMISSION_PCT is not null
and job_id like '%REP'
;

select e1.employee_id ,e1.last_name,e1.MANAGER_ID,e2.last_name
from employees e1,EMPLOYEES e2
where e1.MANAGER_ID=e2.EMPLOYEE_ID and
e1.department_id=80
;

select first_name||' '||last_name as name ,d.DEPARTMENT_NAME
from employees e, DEPARTMENTS d, locations l
where e.DEPARTMENT_ID=d.DEPARTMENT_ID
and d.location_id=l.location_id
and l.city='Seattle'
;

select p1.pname,p1.PRICE
from pub p1,pub p2
where p1.pname=p2.pname
and p1.PRICE<>p2.PRICE
;
select e1.ename,e2.ename
from emp e1,emp e2
where e1.mgr=e2.empno(+)
;


select ename,emp.deptno,dept.deptno,dept.dname
from emp ,dept
where dept.deptno=emp.deptno(+)
;
select e1.ename,e2.ename
from emp e1,emp e2
where e1.mgr(+)=e2.empno

;
select e1.ename,e2.ename
from emp e1,emp e2
where e1.mgr=e2.empno(+)

;

select e1.ename,e2.ename
from emp e1,emp e2
where e1.mgr=e2.empno

;


inner join 
on 
=(+)
left outer join
on
(+)=
right outer join
on

full outer join 
on

select *
from t1 left outer join t2
on t1.a=t2.a(+)

select *
from t1 right outer join t2
on t1.a(+)=t2.a




0206

select *
from emp e , dept d
where

equi  e.dept.no=d.deptno
no-euqi   
self

SELECT *
FROM emp e,salgrade s
WHERE e.sal>=s.losal and e.sal<=s.hisal
;


SELECT e1.ename,e1.mgr,e2.ename
FROM emp e1,emp e2
WHERE e1.empno=e2.MGR
;


SELECT e1.ename,e2.MGR,nvl(e2.ename,'ceo')
FROM emp e1 ,emp e2
WHERE e1.MGR=e2.empno(+)

;

SELECT e2.ename,nvl(e1.ename,'no emp')
FROM emp e1 ,emp e2 
WHERE e1.MGR(+)=e2.empno

;

SELECT *
FROM emp cross join DEPT


;

SELECT empno,ename,dname
FROM emp inner join dept 
on emp.deptno=dept.DEPTNO
;

select  e.empoyess_id,e.fist_name,d.department_name
from employees e inner join departments d 
on e.department_id=d.department_id

;

select  e.employee_id,e.first_name,d.department_name,j.JOB_TITLE
from employees e inner join departments d 
on e.department_id=d.department_id
join jobs j
on e.job_id=j.JOB_ID

;

select  e.employee_id,e.first_name,d.department_name,j.JOB_TITLE
from employees e inner join departments d 
on e.department_id=d.department_id
inner join jobs j
on e.job_id=j.JOB_ID
where job_title='Accountant'

;


select *
from employees e inner join departments d 
--on e.department_id=d.department_id
using (department_id )


;

null값이 빠진 조인 inner 조인
null값을 사용  outer 조인


select *
from employees e right outer join departments d 
on e.department_id=d.department_id
;


select *
from employees e right outer join departments d 
on e.department_id=d.department_id
where e.EMPLOYEE_ID is null
;


create table dept01
(
deptno number(2),
dname varchar(14));

select *
from dept01 left outer join dept02
on dept01.DEPTNO=dept02.DEPTNO;

select *
from dept01 right outer join dept02
on dept01.DEPTNO=dept02.DEPTNO;

select *
from dept01 full join dept02
on dept01.DEPTNO=dept02.DEPTNO;


select e.employee_id,e.first_name|| ' '|| e.last_name,e.job_id,d.DEPARTMENT_ID,d.DEPARTMENT_NAME,l.LOCATION_ID,j.JOB_TITLE,l.CITY,l.STATE_PROVINCE
from EMPLOYEES e full outer join DEPARTMENTS d
on e.DEPARTMENT_ID=d.DEPARTMENT_ID
full outer join jobs j
on e.JOB_ID=j.JOB_ID
full outer join LOCATIONS l
on d.LOCATION_ID=l.LOCATION_ID
where lower(l.CITY)='toronto'
;

select *
from EMPLOYEES e , DEPARTMENTS d,locations l
where e.DEPARTMENT_ID=d.DEPARTMENT_ID
and d.LOCATION_ID=l.LOCATION_ID
and l.CITY='Toronto'
;

select dname,deptno
from dept
where deptno=(select deptno
                     from emp
                    where ename='FORD')
;

select *
from emp
where deptno=(select deptno
                     from emp
                    where ename='SMITH')
   and ename<>'SMITH'    --본인을 제외한
;


select *
from emp
where JOB=(select job
                     from emp
                    where ename='SMITH')
   and ename<>'SMITH'    --본인을 제외한
;

select *
from emp
where SAL>=(select sal
from emp
where ename='SMITH')
;
select *
from emp
where SAL>=(select sal
from emp
where ename='ALLEN');


select *
from emp
where deptno=(select deptno
from dept
where loc='DALLAS')
;

select ename,sal
from emp
where deptno=(select deptno
from dept
where dname='SALES');

SELECT ename , sal
FROM emp
WHERE mgr=(SELECT empno
FROM emp
WHERE ename='KING');

SELECT e1.ename , e1.sal
FROM emp e1 inner join emp e2
on e1.mgr=e2.empno
where e2.ename='KING'
;

SELECT e1.ename , e1.sal
FROM emp e1,emp e2
where e1.mgr=e2.empno
and e2.ename='KING'
;

select sal
from emp
where sal>=(select avg(sal) from emp)
;


select ename,deptno,sal
from emp
where deptno in (select deptno
from emp
where sal>=3000)
;


select max(sal)
from emp
group by deptno
;

select *
from emp
where sal in (select max(sal)
from emp
group by deptno)
;

select *
from emp
where hiredate in (select max(hiredate)
from emp
)
;

select empno,ename,sal
from emp e1
where sal in(select max(sal) from emp e2 
where e1.deptno=e2.deptno 
group by deptno)
;

select deptno,dname,loc
from dept
where deptno in ( select deptno from emp where job='MANAGER')
;

select *
from emp
where hiredate in ( select max(hiredate) from emp );

select *
from emp
where empno not in ( select mgr
from emp
where mgr is not null );

select *
from emp
where empno in ( select mgr
from emp
where mgr is not null );

select e1.empno,e1.ename,e1.sal,e2.job
from emp e1,emp e2
where e1.empno=e2.mgr(+)
;

select e1.empno,e1.ename,e1.sal,e1.job
from emp e1 left outer join emp e2
on e1.empno =e2.mgr(+)
where e2.JOB is null
;
select e1.empno,e1.ename,e1.sal,e1.job
from emp e1 left outer join emp e2
on e1.empno =e2.mgr
where e2.JOB is null
;
select *
from emp
where empno in (select empno from emp where mgr is null)
;

select ename,sal
from emp
where sal >all (select sal from emp where deptno=30);

select ename,sal
from emp
where sal >all (select max(sal) from emp group by deptno having deptno=30);

select ename,sal
from emp
where sal>(select max(sal) from emp where deptno=30);

select ename,sal
from emp
where sal >=all(select sal from emp where job ='SALESMAN')
and job<>'SALESMAN';


select ename,sal
from emp
where sal >(select max(sal) from emp where job='SALESMAN');

select ename,sal
from emp
where sal >any(select sal from emp where deptno=30);
any 자료중 하나

select ename,sal
from emp
where sal >(select min(sal) from emp where deptno=30);

select ename,sal
from emp
where sal >(select min(sal) from emp group by deptno having deptno=30);
select ename ,sal
from emp
where sal> any(select sal from emp where job='SALESMAN')
;
select ename ,sal
from emp
where sal< any (select avg(sal) from emp group by deptno )
;

select ename ,sal
from emp
where sal< all (select avg(sal) from emp group by deptno )
;

select ename ,sal
from emp e1
where sal< all (select avg(sal) from emp e2 where e1.deptno=e2.deptno group by deptno )
;
평균과 그룹 각 부서

select l.location_id,l.street_address,l.city,l.state_province,c.country_name
from countries c ,locations l
where c.country_id=l.country_id
;
select l.location_id,l.street_address,l.city,l.state_province,c.country_name
from countries c natural join locations l

;
select l.location_id,l.street_address,l.city,l.state_province,c.country_name
from countries c inner join locations l
on l.country_id = c.country_id
;

SELECT e.LAST_NAME,  e.job_id,d.department_id,d.department_name
FROM employees e, departments d, locations l
where e.department_id=d.department_id
and d.location_id=l.location_id
and l.city='Toronto'
;

SELECT e.LAST_NAME employee,
  e.EMPLOYEE_ID emp#,
  e2.LAST_NAME manager,
  e2.EMPLOYEE_ID mgr#
FROM employees e,
  employees e2
WHERE e.MANAGER_ID = e2.EMPLOYEE_ID
;

SELECT 
  e1.EMPLOYEE_ID,
  e1.LAST_NAME,
  e1.MANAGER_ID,
  e2.EMPLOYEE_ID ,
  e2.LAST_NAME  ,
  e2.MANAGER_ID 
FROM employees e1,
  employees e2
WHERE e1.MANAGER_ID(+) = e2.EMPLOYEE_ID
and e1.employee_id is null
;
select ename,job
from emp
where ename='&e'


SELECT last_name, hire_date
FROM employees
WHERE department_id = (SELECT department_id
 FROM employees
 WHERE last_name = '&&Enter_name')
AND last_name <> '&Enter_name'; 

SELECT EMPLOYEE_ID,LAST_NAME,SALARY
FROM employees
WHERE SALARY>=  (SELECT avg(salary)
 FROM employees )order by salary
; 

SELECT EMPLOYEE_ID,LAST_NAME
FROM employees
WHERE last_name = any (SELECT LAST_NAME
 FROM employees where last_name like '%u%')
 
; 

ddl create alter drop
dml insert update delete
dql select

select ROWID,empno,ename
from emp;

select name,age,to_char(birth,'yyyy-mm-dd hh24:mi:ss') from s1;

insert into s1(NAME ,AGE, BIRTH , B_MONTH ) values('aaa',30,'2010-01-02',INTERVAL '36' month);

insert into s1(NAME ,AGE, BIRTH , B_MONTH ) values('bbb',20,'2011-01-01',INTERVAL '3' year);

insert into p1 values(1,'a',interval '003-02' year(3)to month);


create table s2( s2_val interval day(3) to second);
insert into s2 values( interval '3 12' day to hour);
insert into s2 values( interval '3 12' day(3) to hour);
insert into s2 values( interval '30' hour);
select * from s2;

create table tempemp4

insert into table
select * from *table


as select empno,ename from emp where 1=0;

number 
char 
varchar2 
date 
interval year to month 
interval day to second
interval '300' year(3)
interval '400' month(3)
interval '3-02' year to month
interval '4 4' 
select into
insert into
insert into select

create table dept10
as select * from emp where 1=0

insert all when deptno=10 then into dept10 values (empno,ename,job,mgr,hiredate,sal,comm,deptno)
when DEPTNO=20 then into dept20 values(empno,ename,job,mgr,hiredate,sal,comm,deptno)
when DEPTNO=30 then into dept30 values(empno,ename,job,mgr,hiredate,sal,comm,deptno)
select * from emp;



truncate table dept10;
truncate table dept20;
truncate table dept30;

alter table dept20 drop column job;
alter table dept20 drop column mgr;
alter table dept20 drop column sal;
alter table dept20 drop column comm;
desc dept20;

insert all when deptno=10 then into dept10 
when DEPTNO=20 then into dept20 values(empno,ename,hiredate,deptno)
when DEPTNO=30 then into dept30 
select * from emp;

select *
from  (select e.empno,e.ename,d.dname
from emp e inner join dept d
on e.deptno=d.deptno);

select empno,ename,sal,sal-(select avg(sal) from emp )
from emp;

select empno,ename,sal,(select avg(sal)from emp),sal-(select avg(sal) from emp )
from emp;

select empno,ename,sal,trunc((select avg(sal)from emp)),sal-trunc((select avg(sal) from emp ))
from emp;

NOT NULL 열에 null 값을 포함할 수 없음을 지정
UNIQUE 테이블의 모든 행에 대해 값이 고유해야 하는 열 또는 열 조합을 지정
PRIMARY KEY 테이블의 각 행을 고유하게 식별
FOREIGN KEY 특정 테이블의 열과 참조 테이블의 열 간에 참조 무결성을 설정하고 적용하여 한 테이블의 값이 다른 테이블의 값과 일치하도록 합니다.
참조되는 테이블의 칼럼의 값이 존재하면 허용한다.
(primary key 를 받아오는것)
CHECK 참이어야 하는 조건을 지정합니다.

create table student( 
stid varchar(20) CONSTRAINT PK_student_stid PRIMARY KEY 
,stname varchar(10) constraint nn_student_stname not null
,jumsu number(3) constraint ck_student_jumsu 
check(jumsu>=0 and jumsu <=100)
);

ORA-00001: unique constraint (SCOTT.PK_STUDENT_STID) violated
ORA-01400: cannot insert NULL into ("SCOTT"."STUDENT"."STID")

not null
primary key 
nou null unique
check

desc user_objects;
desc user_tables;
desc USER_CONSTRAINTS;


SELECT user_objects.OBJECT_NAME,
  user_objects.OBJECT_ID,
  user_objects.OBJECT_TYPE
FROM user_objects
;
select T.TABLE_NAME,T.TABLESPACE_NAME
from user_tables t;

SELECT user_constraints.OWNER,
  user_constraints.CONSTRAINT_NAME,
  user_constraints.TABLE_NAME,
  user_constraints.CONSTRAINT_TYPE
FROM user_constraints
;
SELECT OWNER,
  CONSTRAINT_NAME,
  TABLE_NAME,
  CONSTRAINT_TYPE
FROM user_constraints
;
select owner,constraint_name,constraint_type,search_condition,r_constraint_name from user_constraints;

select * from USER_CONS_COLUMNS;
select constraint_type,constraint_name from user_constraints;

create table t1 (tcode Varchar2 (20)constraint uk_tcode unique)
ORA-00001: unique constraint (SCOTT.UK_TCODE) violated

alter table t1 drop constraint uk_tcode;
create table school (
hcode varchar2(20) constraint pk_school_hcode primary key
,hname varchar2(20) );
create table student 
(
 stcode varchar2(20) constraint pk_student_stcode primary key
 ,stname varchar2(20) 
 ,addr varchar2(20)
 ,hcode varchar2(20) constraint fk_school_student references school(hcode) 
)
;
insert into student (stcode, hcode) values ('1202',null);
insert into student (stcode, hcode) values ('1203','a07'); -integrity constraint (SCOTT.FK_SCHOOL_STUDENT) violated - parent key not found
create table df
( name varchar2(20)
,addr varchar2(20) default '서울'
);

create table member( 
mid varchar2(20),
mname varchar2(20),
maddr varchar2(100),
mdept varchar2(20)
,constraint pk_mid primary key(mid)
,constraint ck_mdept check(mdept in ('a','b','c'))
,constraint uk_mname unique(mname)
);

create table member2( 
mid varchar2(20),
mname varchar2(20),
maddr varchar2(100),
mdept varchar2(20),
phone varchar2(20) constraint nn_phone not null
,constraint pk_mid primary key(mid)
,constraint ck_mdept check(mdept in ('a','b','c'))
,constraint uk_mname unique(mname)

);
create table hak( 
hakcode varchar2(2)
, hakname varchar2(10)
, constraint pk_kah primary key(hakcode));

constraint pk_stcode primary key(stcode1,stcod2)
constraint fk_hak foreign key ( hakcode) references hak(hakcode)
decode
case 
when
then
inner join
eqjoin
left outer join
ansi 
where 
subquery
 create table s1 ( sid varchar2(20) primary key);
alter table s1 add sname varchar2(20) constraint nn_sname not null;
alter table s1 add jumsu NUMBER(3);
alter table s1 drop column jumsu;
create table dept02 as select * from dept where 1=0;
alter table dept02 add dmgr number(4);
alter table dept02 modify loc varchar2(40);
alter table dept02 modify loc varchar2(30);
select length(loc) from dept02;
alter table dept02 modify loc varchar2(10);--01441: cannot decrease column length 
alter table dept02 drop column loc;
auto commit 
commit
quit exit
ddl
update table_name set exp  where exp2
alter table table_name set unused(job);
drop table table_name;
drop table table_name purge;
truncate table table_name;
rename s1 to p1;
create alter drop

insert update delete
update set

delete from tab1;

SELECT user_tables.TABLE_NAME,
  
  user_tables.TABLESPACE_NAME
FROM user_tables;
create table tempemp as select * from emp where 1=0;
create table tempemp1(empno,ename)as select empno,ename from emp;
insert into tempemp select * from emp where deptno=10;
create table emp1 as select empno,ename,hiredate from emp where 1=0;
create table emp2 as select empno,ename,sal from emp where 1=0; 

insert all
into emp1 values(empno,ename,hiredate)
into emp2 values(empno,ename,sal)
select empno,ename,hiredate,sal from emp;

insert all
when substr(hiredate,1,2)='80' then into tb1 values(ename,hiredate)
when substr(hiredate,1,2)='81' then into tb2 values(ename,hiredate)
when substr(hiredate,1,2)='82' then into tb3 values(ename,hiredate)
select ename,hiredate from emp ;

insert all
when to_char(hiredate,'yyyy')='1980' then into y80
when to_char(hiredate,'yyyy')='1981' then into y81
when to_char(hiredate,'yyyy')='1982' then into y82
select * from emp;

varchar2
number
date
primary  not null unique 결합모양
contraint pk_id primary key
not null
check
unique
forign key

refid number(3) constraint fk_id references aaa(id)

merge 

merge into emp01
using emp02
on (emp01.empno=emp02.empno)
when matched then 
update set emp01.job=emp02.job
when not matched then
insert (emp01.empno,emp01.ename,emp01.job) values (emp02.empno,emp02.ename,emp02.job);

ddl create alter drop rename truncate

savepoint [savepoint]

rollback to [savepoint]

create table test  as select * from emp ;
update test set 

update test set job='clerk' where ename='aaa';

lan local
wan wide
host

lock
dead lock

tempemp 
empno number(7) 
ename varchar(10) not null
job   varchar(20) 'a','b','c'
hiredate  date    1910>date and date

create table tempemp
( empno number(7)
,ename varchar2(10) constraint nn_ename not null 
, job varchar2(20) constraint ck_job check(job in ( 'a','b','c')
,hiredate date constraint ck_hiredate check(hiredate>=sysdate);

alter table t1 add birth date constraint ck_birth 
check(birth>=to_date('1990-01-01','yyyy-mm-dd'));


create table tempemp1
( empno number(7)
,ename varchar2(10) constraint nn_ename not null 
, job varchar2(20) constraint ck_job check(job in ( 'a','b','c'))
,hiredate date constraint ck_hiredate check(hiredate>=to_date('1910-01-01','yyyy-mm-dd'))
);

EXTRACT

create table test(
empno number(7)
,ename varchar2(10) constraint nn_ename not null
,job varchar2(20)
,hiredate date default sysdate
,constraint pk_empno primary key(empno)
,constraint ck_job check(job in ('a','b','c'))
,constraint ch_hiredate check ( hiredate >=to_date('1910-01-01','yyyy-mm-dd'))
);

alter table con1 add constraint pk_cid1 primary key(cid);

alter table con1 drop constraint pk_cid1;

alter table emp01
add constraint emp01_empno_pk primary key(empno);

alter table emp01
add constraint emp01_deptno_fk 
foreign key(deptno) references dept(deptno);

alter table emp01
modify ename constraint emp01_ename_nn not null;

alter table emp05
drop constraint emp05_empno_pk;

alter table emp05
drop constraint emp05_ename_nn;




alter table emp1 add constraint fk_emp_deptno foreign key (deptno) references dept1(deptno);

drop table dept1 drop constraint pk_deptno cascade;
create table dept01(
deptno number(2) constraint dept01_deptno_pk primary key,
dname varchar2(14),
loc varchar2(13)
);

create table emp01( 
empno number(4) 
constraint emp01_empno_pk primary key ,
ename varchar2(10) 
constraint emp01_ename_nn not null, 
job varchar2(9), 
deptno number(4) 
constraint emp01_deptno_fk references dept01(deptno)
); 

alter table emp01 add constraint fk_emp1_deptno foreign key (deptno) references dept1(deptno) on delete cascade;
부모 삭제 자식 삭제

delete from dept1 where deptno='c';

insert into dept1(deptno,dname) values(1,'a');

select constraint_name from user_constraints;

alter table dept1
add constraint pk_dept1_deptno primary key(deptno)

alter table emp1
add constraint fk_emp_deptno foreign key(deptno)references dept1(deptno) on delete cascade;

insert into dept1 values
insert into emp1 values

delete dept1 where deptno

alter table emp1 drop constraint fk_emp_deptno;

add constraint fk_emp_deptno foreign key(deptno)references dept1(deptno)

grant create view to scott;

create view v1
as select empno,ename,sal,hiredate from emp;

select * from v1;

create view v1 as select empno,ename,hiredate from emp;
--ORA-00955: name is already used by an existing object

create or replace view v1 as select empno,ename,sal,hiredate from emp;

create or replace view v2(irum,salary,hire) 컬럼헤드부여
as select ename,sal,hiredate from emp;

view 보안 편리

create view emp_view20 as select empno,ename,deptno,mgr from emp;

create or replace view emp_copy as select empno from emp;

desc user_objects;

select object_name,
object_id,
object_type from user_objects;

desc user_views;

select view_name,text,text_length from user_views;

text-쿼리

create view emp_v1 as select * from copy_emp;

create or replace view emp_v1 as select empno,ename,sal from copy_emp;

insert into emp_v1 values(1,'hong',100);

select * from emp_v1;
뷰 밸류 생성 후 원래 테이블 확인
select * from copy_emp;

create view view_dept30 as select * from copy_emp where deptno=30;

insert into view_dept30 values(100,'park',30,100,'90/01/01');

insert into view_dept30 values(101,'apap',50,1000,'99-01-01');

select * from copy_emp;

update view_dept30 set deptno=40 where empno = 100;

create or replace view view_dept30 as select * from COPY_EMP where deptno=30;

insert into view_dept30 values(100,'mmbm',30,100,'90-10-10');

update view_dept30 set deptno=40 where empno=100;

create or replace view view_dept30
as 
select empno, ename, sal, deptno 
from copy_emp
where deptno=30 with check option;
조건만 insert update delete 

read only

create view temp_v1
as select d.dname,max(sal) as bb,min(sal) as cc
from emp e,dept d
where e.deptno=d.deptno 
group by d.dname
;

view drop
select view_name,text from user_views;

rownum 번호매김

select rownum ,empno,ename from emp ;
select rownum ,empno,ename from emp where rownum<4;

select * from (select rownum as rnum,empno,ename from emp );

select e.rnum,e.empno,e.ename
from (select rownum as rnum,empno,ename from emp ) e;

select e.rnum,e.empno,e.ename
from (select rownum as rnum,empno,ename from emp ) e
where rnum>=3 and rnum<=7;

select empno,ename
from emp
where ename like '%E%';

select a.rnum,a.empno,a.ename,a.sal
from(select rownum as rnum,empno,ename,sal
from emp
where ename like '%E%'
order by sal) a
where rnum>=3 and rnum<=7
;

select *
from(select rownum as rnum,a.* 
from(select empno,ename,sal
from emp
where ename like '%E%'
order by sal) a)
where rnum>=3 and rnum<=6
;

select *
from(select rownum as rnum,a.* 


from(select empno,ename,sal
from emp
where ename like '%E%'
order by sal) a where rownum<=6 )
where rnum>=3 
;

select *
from(select rownum as rnum,a.*
from(select empno,ename,hiredate
from emp
order by hiredate desc)a)
where rnum<6;


select *
from(select rownum as rnum,s.*
from(select ename,sal,hiredate,job,dname
from emp,dept
where emp.deptno=dept.deptno
order by sal desc)s)
where rnum>=3 and rnum<7
;

create sequence seq1;
insert into t1 values(seq1.nextval,'e');
select * from t1;

insert into t2  values (seq1.nextval,'d');
select * from t2;
sequence value 가 이어짐


테이블 추가 삭제 수정
뷰
시퀀스
grant 
조인
group by
having
트랜잭션
savepoint
제약조건
plsql
인덱스

create table tt
( tid number constraint prk_fid primary key
);

alter table tt
add tname varchar2(10) constraint nn_tname not null;
alter table tt
add ck_tname check(tname)

create table tt2
(
tid2 number
tname varchar2(20)

)

alter table tt2
add constraint tid2 pk_tid2 primary key (tid2);
alter table tt2
add  rfid nunber constraint fk_rfid foreign key ( tid2) references tt(tid) on delete cascade;
alter table tt2 drop column tname;
alter table tt2 drop constraint pk_tname;

commit rollback savepoint

savepoint [savepoint]
rollback to [savepoint]

create table t2
(
tid number constraint pk_tid primary key 
,tname varchar2(20)
);

update t2 set tname='hong' where tid=1;

 select s.sid,s.serial#,s.username,r.name
 from v$session s,v$transactiont t,v$rollname r
 where s.taddr=t.addr
 and t.xidusn=r.usn

drop view v1;
drop view view1;

alter table t1 add refid number constraint fk_refid references t2(tid);
alter table t1 drop column refid;
alter table t2
add refid number;

alter table t2
add constraint tk_refid foreign key(refid) reference t2(tid);

create sequence seq;
select seq.nextval from dual;
select seq.currval from dual;

start with
increment with
desc user_sequences;
drop sequence seq;

create sequence seq2
start with 10
increment by 3;
select seq2.nextval from dual;

create sequence seq3 
start with 10 
increment by 5 
maxvalue 20 
minvalue 0;

create sequence se3 start with 2 increment by 3 maxvalue 21 cycle  nocache ;

cache 

grant create view to scott

alter sequence [sequence_name]

index 인덱스 

자동으로 생성 수동으로 생성

묶은게 세그먼트

세그먼트안에 데이터 블럭으로 순서대로 저장한다.

b트리로 관리

고유 인덱스 순서를 정해줄 경우 중복이 안됨
비고유인덱스 중복됨 사용자가 정해주는 경우
세그먼트 단위로 저장 한 후에 물리적으로 정렬 순서를 정한다.

desc user_ind_columns;
select * from user_ind_columns;
select * from user_cons_columns;
select constraint_name ,table_name,column_name from user_cons_columns;
select index_name,table_name,column_name from user_ind_columns;

set timing on;
create index i_emp on emp(hiredate);

select index_name,table_name,column_name from user_ind_columns where table_name in('emp');
create index ind_emp_job on emp(job);

select * from user_ind_columns where table_name='EMP';

rebuild

declare~begin ~ exception~end

declare section

executable section

exception section
 
set serveroutput on

begin
end;

begin dbms_output.put_line('hello');
end;

exec dbms_output.put_line('hello honghonghong'); 프로시져 실행

begin
dbms_output.put_line('akdsfklafj');
dbms_output.put_line('ksjdaflksjlkdfjaklfjklad');
end;


declare
 v_sum1 number :=0;
 v_sum2 number;
begin
 dbms_output.put_line('해당자료는'||v_sum1);
 v_sum2:=10;
 dbms_output.put_line('다음자료는'||v_sum2);
end;

declare
 v_sum1 number :=20;
 v_sum2 number;
begin
 dbms_output.put_line('해당자료는'||v_sum1);
 v_sum2:=100;
 dbms_output.put_line('다음자료는'||v_sum2);
end;

declare
vempno number(4);
vename varchar2(20);
begin
vempno :=7788;
vename :='parkkim';
dbms_output.put_line('사번  이름');
dbms_output.put_line(vempno||'  '||vename);
end;

@abc.sql
or
@abc

declare
result_ename varchar2(10);

begin

select ename into result_ename
from emp
where empno=7902;
dbms_output.put_line(result_ename);

end;

declare
result_ename emp.ename%type;

begin

select ename into result_ename
from emp
where empno=7902;
dbms_output.put_line(result_ename);

end;

declare
aaa emp.ename%type;
bbb emp.deptno%type;
ccc emp.sal%type;
begin
select ename,deptno,sal into aaa,bbb,ccc
from emp
where ename='KING';
dbms_output.put_line(aaa||'  '||bbb||'   '||ccc);
end;

declare
aaa emp.ename%type;
bbb emp.deptno%type;
ccc emp.sal%type;
begin
select ename,deptno,sal into aaa,bbb,ccc
from emp
where ename='KING';
dbms_output.put_line('이름   부서   급여');
dbms_output.put_line(aaa||'  '||bbb||'   '||ccc);
end;


declare
v_dname dept.dname%type;

begin

select d.dname into v_dname
from emp e inner join dept d
on e.deptno=d.deptno
where e.ename='KING';

dbms_output.put_line(v_dname);
end;

declare
v_dname dept.dname%type;
v_ename varchar2(20);
v_sal emp.sal%type;
v_empno emp.empno%type;
v_hiredate emp.hiredate%type;
begin

select d.dname,e.ename, e.sal,e.empno,e.hiredate
into v_dname,v_ename,v_sal,v_empno,v_hiredate
from emp e inner join dept d
on e.deptno=d.deptno
where e.ename='KING';

dbms_output.put_line(v_empno||'  '||v_ename||'  '||v_sal||'  '||'  '||v_hiredate||'  '||v_dname);
end;


declare
v_dname dept.dname%type;
v_ename varchar2(20);
v_sal emp.sal%type;
v_empno emp.empno%type;
v_hiredate emp.hiredate%type;
begin

select d.dname,e.ename, e.sal,e.empno,e.hiredate
into v_dname,v_ename,v_sal,v_empno,v_hiredate
from emp e , dept d
where e.deptno=d.deptno
and e.ename='KING';

dbms_output.put_line(v_empno||'  '||v_ename||'  '||v_sal||'  '||'  '||v_hiredate||'  '||v_dname);

dbms_output.put_line(v_empno);
dbms_output.put_line(v_ename);
dbms_output.put_line(v_sal);
dbms_output.put_line(v_hiredate);
dbms_output.put_line(v_dname);


end;


declare
v_emp emp%rowtype;

begin

select *
into v_emp
from emp 
where ename='KING';

dbms_output.put_line(v_emp.empno);
dbms_output.put_line(v_emp.ename);
end;


프로시져 명령문 저장

create procedure [procedure]
is 

create or replace


exec proc1();

select * from user_source;

create or replace procedure proc1(a number)
is
v_avg number:=0;
begin
 select avg(sal) into v_avg
 
 from emp
 where deptno=a;
 dbms_output.put_line(v_avg);
end;

exec proc1(10);

show error;


create or replace procedure proc1(a number)
is
v_sal number:=0;
begin
 select sal into v_sal
 from emp
 where empno=a;
 dbms_output.put_line(v_sal);
 exception 
 when NO_data_found then 
 dbms_output.put_line('no data');
end;

exec proc1(20);


create or replace procedure proc1(a number)
is
v_sal number:=0;

begin
 select avg(sal) into v_sal
 from emp
 where deptno=a;
 dbms_output.put_line(v_sal);
 exception 
 when NO_data_found then 
 dbms_output.put_line('no data');
end;

exec proc1(20);

create or replace procedure proc1(a number)
is
v_sal number:=0;

begin
 select avg(sal) into v_sal
 from emp e right outer join dept d
 on e.deptno=d.deptno
 where e.deptno=a;
 dbms_output.put_line(v_sal);
if v_sal is null then 
 dbms_output.put_line('사원이 없습니다.');
 else
  dbms_output.put_line('해당 부서 평균은'||v_sal);
end if;

end;

create or replace procedure main
is
begin 
 begin 
  dbms_output.put_line('first');
 end;
 begin
  dbms_output.put_line('second');
 end;
end;

exec main;

create or replace procedure sub1
is
begin
dbms_output.put_line('first');
end;

create or replace procedure sub2
is
begin
dbms_output.put_line('second');
end;

create or replace procedure main
is
begin
 begin
  sub1;
  sub2;
 end;
end;

exec main;


declare
 v_rec emp%rowtype;
begin
select * into v_rec
from emp
where empno=7782;

dbms_output.put_line(v_rec.empno);
dbms_output.put_line(v_rec.ename);
dbms_output.put_line(v_rec.job);
end;

declare
 type emp_record_type is record(       );
 emp_record emp_record_type;


create or replace procedure deproc2(a number)
is
type empdept_rec_type is record( 
empno emp.empno%type
,ename emp.ename%type
,sal emp.sal%type
,deptno emp.deptno%type
);
emprec empdept_rec_type;
begin
 select empno,ename,sal,deptno 
 into emprec
 from emp
 where empno=a;
 dbms_output.put_line(emprec.empno);
 dbms_output.put_line(emprec.ename);
 dbms_output.put_line(emprec.sal);
 dbms_output.put_line(emprec.deptno);
 exception
 when no_data_found
 then dbms_output.put_line('no data');

end;

exec deproc2(7782);

create or replace procedure [procedure_name]
is
type [type_record_name] is record
(
  empno emp.empno%type
, ename emp.ename%type
, sal emp.sal%type
, deptno emp.deptno%type
);

emprec [type_record_name];
 begin
  select empno,ename,sal,deptno
  from emp
   where deptno=a;
dbms_output.put_line(emprec.empno);
dbms_output.put_line(emprec.ename);
dbms_output.put_line(emprec.sal);
dbms_output.put_line(emprec.deptno);

exception
when no_data_found then dbms_output.put_line('no data');

end;

create or replace procedure result(a number)
is 
type result_rec is record
(
empno emp.empno%type
,ename emp.ename%type
,hiredate emp.hiredate%type
,sal emp.sal%type
,deptno emp.deptno%type
);
recs result_rec;
 begin
 select empno,ename,hiredate,sal,deptno
 from emp
 where empno=a;
 if recs.sal<=2000 then dbms_output.put_line('bad');
 elsif recs.sal>=2000 or recs.sal<4000 then dbms_output.put_line('good');
 else recs.sal>4000 then dbms_output.put_line('very good');
 end if;
  end;
  

show error;

create or replace procedure deproc2(a number)
is
type empdept_rec_type is record( 
empno emp.empno%type
,ename emp.ename%type
,sal emp.sal%type
,deptno emp.deptno%type
);
emprec empdept_rec_type;
begin
 select empno,ename,sal,deptno 
 into emprec
 from emp
 where empno=a;
 dbms_output.put_line(emprec.empno);
 dbms_output.put_line(emprec.ename);
 dbms_output.put_line(emprec.sal);
 dbms_output.put_line(emprec.deptno);
 if emprec.sal<=2000  then dbms_output.put_line('bad');
 elsif emprec.sal>=2000 and emprec.sal<4000 then dbms_output.put_line('good');
 else dbms_output.put_line('very good');
 end if;
  exception
 when no_data_found then dbms_output.put_line('no data');
  end;
  
exec deproc2(7782);
show error;
